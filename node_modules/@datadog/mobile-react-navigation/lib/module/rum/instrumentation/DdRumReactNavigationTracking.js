function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2016-Present Datadog, Inc.
 */
import { DdRum, SdkVerbosity, InternalLog } from '@datadog/mobile-react-native';
import { AppState, BackHandler } from 'react-native';

/**
 * Provides RUM integration for the [ReactNavigation](https://reactnavigation.org/) API.
 */
export class DdRumReactNavigationTracking {
  /**
   * Starts tracking the NavigationContainer and sends a RUM View event every time the navigation route changed.
   * @param navigationRef the reference to the real NavigationContainer.
   */
  static startTrackingViews(navigationRef, viewNamePredicate = function (_route, trackedName) {
    return trackedName;
  }) {
    if (navigationRef == null) {
      InternalLog.log(DdRumReactNavigationTracking.NULL_NAVIGATION_REF_ERROR_MESSAGE, SdkVerbosity.ERROR);
      return;
    }

    if (DdRumReactNavigationTracking.registeredContainer != null && this.registeredContainer !== navigationRef) {
      InternalLog.log(DdRumReactNavigationTracking.NAVIGATION_REF_IN_USE_ERROR_MESSAGE, SdkVerbosity.ERROR);
    } else if (DdRumReactNavigationTracking.registeredContainer == null) {
      DdRumReactNavigationTracking.viewNamePredicate = viewNamePredicate;
      const listener = DdRumReactNavigationTracking.resolveNavigationStateChangeListener();
      DdRumReactNavigationTracking.handleRouteNavigation(navigationRef.getCurrentRoute());
      navigationRef.addListener('state', listener);
      DdRumReactNavigationTracking.registeredContainer = navigationRef;
      DdRumReactNavigationTracking.backHandler = BackHandler.addEventListener('hardwareBackPress', DdRumReactNavigationTracking.onBackPress);
      this.appStateSubscription = AppState.addEventListener('change', DdRumReactNavigationTracking.appStateListener);
    }
  }
  /**
   * Stops tracking the NavigationContainer.
   * @param navigationRef the reference to the real NavigationContainer.
   */


  static stopTrackingViews(navigationRef) {
    if (navigationRef != null) {
      var _DdRumReactNavigation;

      navigationRef.removeListener('state', DdRumReactNavigationTracking.navigationStateChangeListener);
      (_DdRumReactNavigation = DdRumReactNavigationTracking.backHandler) === null || _DdRumReactNavigation === void 0 ? void 0 : _DdRumReactNavigation.remove();
      DdRumReactNavigationTracking.backHandler = null;
      DdRumReactNavigationTracking.registeredContainer = null;

      DdRumReactNavigationTracking.viewNamePredicate = function (_route, trackedName) {
        return trackedName;
      };
    } // For versions of React Native below 0.65, addEventListener does not return a subscription.
    // We have to call AppState.removeEventListener instead.


    if (this.appStateSubscription) {
      this.appStateSubscription.remove();
    } else {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      AppState.removeEventListener('change', DdRumReactNavigationTracking.appStateListener);
    }
  }

  static handleRouteNavigation(route, appStateStatus = undefined) {
    if (route === undefined || route === null) {
      InternalLog.log(DdRumReactNavigationTracking.ROUTE_UNDEFINED_NAVIGATION_WARNING_MESSAGE, SdkVerbosity.WARN); // RUMM-1400 in some cases the route seem to be undefined

      return;
    }

    const key = route.key;
    const predicate = DdRumReactNavigationTracking.viewNamePredicate;
    const screenName = predicate(route, route.name);

    if (key != null && screenName != null) {
      if (appStateStatus === 'background') {
        DdRum.stopView(key);
      } else if (appStateStatus === 'active' || appStateStatus === undefined) {
        // case when app goes into foreground,
        // in that case navigation listener won't be called
        DdRum.startView(key, screenName);
      }
    }
  }

  static resolveNavigationStateChangeListener() {
    if (DdRumReactNavigationTracking.navigationStateChangeListener == null) {
      DdRumReactNavigationTracking.navigationStateChangeListener = () => {
        var _DdRumReactNavigation2;

        const route = (_DdRumReactNavigation2 = DdRumReactNavigationTracking.registeredContainer) === null || _DdRumReactNavigation2 === void 0 ? void 0 : _DdRumReactNavigation2.getCurrentRoute();

        if (route === undefined) {
          InternalLog.log(DdRumReactNavigationTracking.ROUTE_UNDEFINED_NAVIGATION_WARNING_MESSAGE, SdkVerbosity.WARN);
          return;
        }

        DdRumReactNavigationTracking.handleRouteNavigation(route);
      };
    }

    return DdRumReactNavigationTracking.navigationStateChangeListener;
  }

}

_defineProperty(DdRumReactNavigationTracking, "registeredContainer", void 0);

_defineProperty(DdRumReactNavigationTracking, "navigationStateChangeListener", void 0);

_defineProperty(DdRumReactNavigationTracking, "viewNamePredicate", void 0);

_defineProperty(DdRumReactNavigationTracking, "backHandler", void 0);

_defineProperty(DdRumReactNavigationTracking, "appStateSubscription", void 0);

_defineProperty(DdRumReactNavigationTracking, "ROUTE_UNDEFINED_NAVIGATION_WARNING_MESSAGE", 'A navigation change was detected but the RUM ViewEvent was dropped as the route was undefined.');

_defineProperty(DdRumReactNavigationTracking, "NULL_NAVIGATION_REF_ERROR_MESSAGE", 'Cannot track views with a null navigationRef.');

_defineProperty(DdRumReactNavigationTracking, "NAVIGATION_REF_IN_USE_ERROR_MESSAGE", 'Cannot track new navigation container while another one is still tracked. Please call `DdRumReactNavigationTracking.stopTrackingViews` on the previous container reference.');

_defineProperty(DdRumReactNavigationTracking, "isAppExitingOnBackPress", () => {
  if (DdRumReactNavigationTracking.registeredContainer === null) {
    return false;
  }

  if (DdRumReactNavigationTracking.registeredContainer.canGoBack()) {
    return false;
  }

  return true;
});

_defineProperty(DdRumReactNavigationTracking, "onBackPress", () => {
  if (DdRumReactNavigationTracking.isAppExitingOnBackPress()) {
    DdRumReactNavigationTracking.stopTrackingViews(DdRumReactNavigationTracking.registeredContainer);
  } // We always return false so we make sure the react-navigation callback is called.
  // See https://reactnative.dev/docs/backhandler


  return false;
});

_defineProperty(DdRumReactNavigationTracking, "appStateListener", appStateStatus => {
  var _DdRumReactNavigation3;

  const currentRoute = (_DdRumReactNavigation3 = DdRumReactNavigationTracking.registeredContainer) === null || _DdRumReactNavigation3 === void 0 ? void 0 : _DdRumReactNavigation3.getCurrentRoute();

  if (currentRoute === undefined || currentRoute === null) {
    InternalLog.log(`We could not determine the route when changing the application state to: ${appStateStatus}. No RUM View event will be sent in this case.`, SdkVerbosity.ERROR);
    return;
  }

  DdRumReactNavigationTracking.handleRouteNavigation(currentRoute, appStateStatus);
});
//# sourceMappingURL=DdRumReactNavigationTracking.js.map