import type { PropagatorType } from '../../../types';
import type { Hostname } from './firstPartyHosts';
import type { RegexMap } from './interfaces/RequestProxy';
export declare type DdRumResourceTracingAttributes = {
    tracingStrategy: 'KEEP';
    traceId: TraceId;
    spanId: SpanId;
    samplingPriorityHeader: '1' | '0';
    rulePsr: number;
    propagatorTypes: PropagatorType[];
} | {
    tracingStrategy: 'DISCARD';
    traceId?: void;
    spanId?: void;
    samplingPriorityHeader: '0';
};
export declare const getTracingAttributes: ({ hostname, firstPartyHostsRegexMap, tracingSamplingRate }: {
    hostname: Hostname | null;
    firstPartyHostsRegexMap: RegexMap;
    tracingSamplingRate: number;
}) => DdRumResourceTracingAttributes;
/**
 * Using branded types will ensure we don't accidentally use
 * traceId for spanId when generating headers.
 */
export declare type TraceId = TraceIdentifier & {
    _brand: 'traceId';
};
export declare type SpanId = TraceIdentifier & {
    _brand: 'spanId';
};
export declare class TraceIdentifier {
    private low;
    private high;
    constructor();
    toString: (radix: number) => string;
    /**
     * This function pads the trace with `0`.
     * It should not be used with a `length` lower than the trace, as we return the full trace in this case.
     * @param radix radix for the trace
     * @param length minimum length
     * @returns padded string
     */
    toPaddedString: (radix: number, length: number) => string;
}
