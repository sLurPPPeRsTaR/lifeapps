{"version":3,"sources":["BoundedBuffer.ts"],"names":["InternalLog","SdkVerbosity","getErrorStackTrace","DdSdk","DatadogBuffer","DEFAULT_BUFFER_SIZE","BoundedBuffer","constructor","bufferSize","callback","buffer","length","push","_type","addTelemetryEvent","Promise","resolve","undefined","bufferId","generateRandomBufferId","returnedBufferId","idTable","error","console","warn","Math","random","withBufferId","bufferIndex","item","callbackId","log","WARN","drainTelemetry","tries","hash","toString","slice","Error","message","stack","kind","telemetryBuffer","occurences","Object","values","forEach","telemetryError"],"mappings":"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","sourcesContent":["/*\n * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2016-Present Datadog, Inc.\n */\n\nimport { InternalLog } from '../../../InternalLog';\nimport { SdkVerbosity } from '../../../SdkVerbosity';\nimport { getErrorStackTrace } from '../../../errorUtils';\nimport { DdSdk } from '../../../foundation';\n\nimport { DatadogBuffer } from './DatadogBuffer';\n\nconst DEFAULT_BUFFER_SIZE = 100;\n\ntype VoidCallback = {\n    callback: () => Promise<void>;\n    _type: 'VOID';\n};\n\ntype CallbackReturningId = {\n    callback: () => Promise<string>;\n    returnedBufferId: string;\n    _type: 'RETURNING_ID';\n};\n\ntype CallbackWithId = {\n    callback: (id: string) => Promise<void>;\n    withBufferId: string;\n    _type: 'WITH_ID';\n};\n\ntype BufferItem = VoidCallback | CallbackReturningId | CallbackWithId;\n\nexport class BoundedBuffer extends DatadogBuffer {\n    private bufferSize: number;\n    private buffer: BufferItem[] = [];\n    private idTable: { [bufferId: string]: string | null } = {};\n    private telemetryBuffer: {\n        [kind: string]: {\n            message: string;\n            stack: string;\n            kind: string;\n            occurences: number;\n        };\n    } = {};\n\n    constructor(bufferSize: number = DEFAULT_BUFFER_SIZE) {\n        super();\n        this.bufferSize = bufferSize;\n    }\n\n    addCallback = (callback: () => Promise<void>) => {\n        if (this.buffer.length < this.bufferSize) {\n            this.buffer.push({ callback, _type: 'VOID' });\n        } else {\n            this.addTelemetryEvent('Buffer overflow', '', 'BufferOverflow');\n        }\n\n        return new Promise<void>(resolve => resolve(undefined));\n    };\n\n    addCallbackReturningId = (callback: () => Promise<string>) => {\n        try {\n            const bufferId = this.generateRandomBufferId();\n            if (this.buffer.length < this.bufferSize) {\n                this.buffer.push({\n                    callback,\n                    returnedBufferId: bufferId,\n                    _type: 'RETURNING_ID'\n                });\n                this.idTable[bufferId] = null;\n            } else {\n                this.addTelemetryEvent('Buffer overflow', '', 'BufferOverflow');\n            }\n\n            return new Promise<string>(resolve => resolve(bufferId));\n        } catch (error) {\n            this.addTelemetryEvent(\n                'Could not generate enough random numbers',\n                getErrorStackTrace(error),\n                'RandomIdGenerationError'\n            );\n            // Not using InternalLog here as it is not yet instantiated\n            console.warn(\n                `[Datadog] Could not generate enough random numbers for RUM buffer. Please check that Math.random is not overwritten. Math.random returns: ${Math.random()}`\n            );\n\n            return new Promise<string>(resolve => resolve(''));\n        }\n    };\n\n    addCallbackWithId = (\n        callback: (id: string) => Promise<void>,\n        bufferId: string\n    ) => {\n        if (this.idTable[bufferId] !== undefined) {\n            this.buffer.push({\n                callback,\n                withBufferId: bufferId,\n                _type: 'WITH_ID'\n            });\n        } else {\n            this.addTelemetryEvent('Buffer overflow', '', 'BufferOverflow');\n        }\n\n        return new Promise<void>(resolve => resolve(undefined));\n    };\n\n    drain = async () => {\n        for (\n            let bufferIndex = 0;\n            bufferIndex < this.buffer.length;\n            bufferIndex++\n        ) {\n            try {\n                const item = this.buffer[bufferIndex];\n                if (item._type === 'RETURNING_ID') {\n                    try {\n                        // Here we want to await the callback result to make sure that it has registered the id returned\n                        // by the callback before executing the callback needing this id.\n                        // eslint-disable-next-line no-await-in-loop\n                        const callbackId = await item.callback();\n                        this.idTable[item.returnedBufferId] = callbackId;\n                    } catch (error) {\n                        InternalLog.log(\n                            `Error running a callback returning an id in Buffer: ${error}`,\n                            SdkVerbosity.WARN\n                        );\n                    }\n                    continue;\n                }\n\n                if (item._type === 'WITH_ID') {\n                    const callbackId = this.idTable[item.withBufferId];\n                    // callbackId can be `null` if the callback supposed to return the id errored. In this case, let's ignore the next callback.\n                    if (callbackId !== null && callbackId !== undefined) {\n                        item.callback(callbackId);\n                        delete this.idTable[item.withBufferId];\n                    } else {\n                        InternalLog.log(\n                            `1 event was not sent as callback id was ${\n                                callbackId === null\n                                    ? 'not set'\n                                    : 'already unset'\n                            }`,\n                            SdkVerbosity.WARN\n                        );\n                    }\n                    continue;\n                }\n\n                item.callback();\n            } catch (error) {\n                InternalLog.log(\n                    `Error while draining Datadog Buffer: ${error}`,\n                    SdkVerbosity.WARN\n                );\n            }\n        }\n\n        this.buffer = [];\n\n        this.drainTelemetry();\n    };\n\n    private generateRandomBufferId = (): string => {\n        let tries = 0;\n        while (tries < 20) {\n            const hash = Math.random().toString(36).slice(2);\n            if (this.idTable[hash] !== undefined) {\n                tries++;\n            } else {\n                return hash;\n            }\n        }\n\n        throw new Error('Could not generate random Buffer id');\n    };\n\n    private addTelemetryEvent = (\n        message: string,\n        stack: string,\n        kind: string\n    ) => {\n        if (this.telemetryBuffer[kind]) {\n            this.telemetryBuffer[kind].occurences++;\n        } else {\n            this.telemetryBuffer[kind] = {\n                message,\n                stack,\n                kind,\n                occurences: 1\n            };\n        }\n    };\n\n    private drainTelemetry = () => {\n        Object.values(this.telemetryBuffer).forEach(\n            ({ message, stack, kind, occurences }) => {\n                DdSdk.telemetryError(\n                    `${message} happened ${occurences} times.`,\n                    stack,\n                    kind\n                );\n            }\n        );\n    };\n}\n"]}