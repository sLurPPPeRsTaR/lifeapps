{"version":3,"sources":["DdEventsInterceptor.tsx"],"names":["InternalLog","SdkVerbosity","DdRum","RumActionType","UNKNOWN_TARGET_NAME","DEBOUNCE_EVENT_THRESHOLD_IN_MS","HANDLE_EVENT_APP_EXECUTION_TIME_IN_MS","DD_ACTION_NAME_PROP","DdEventsInterceptor","Number","MIN_VALUE","interceptOnPress","args","length","_targetInst","currentTime","Date","now","timestampDifference","Math","abs","debouncingStartedTimestamp","targetNode","handleTargetEvent","log","ACTION_EVENT_DROPPED_WARN_MESSAGE","WARN","event","resolvedTargetName","resolveTargetName","addAction","TAP","undefined","closestActionLabel","findClosestActionLabel","accessibilityLabel","memoizedProps","elementTypeName","resolveElementTypeName","elementType","name","currentNode","props","return"],"mappings":"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","sourcesContent":["/*\n * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2016-Present Datadog, Inc.\n */\n\nimport type { GestureResponderEvent } from 'react-native';\n\nimport { InternalLog } from '../../../InternalLog';\nimport { SdkVerbosity } from '../../../SdkVerbosity';\nimport { DdRum } from '../../DdRum';\nimport { RumActionType } from '../../types';\n\nimport type EventsInterceptor from './EventsInterceptor';\n\nexport const UNKNOWN_TARGET_NAME = 'unknown_target';\nconst DEBOUNCE_EVENT_THRESHOLD_IN_MS = 10;\nconst HANDLE_EVENT_APP_EXECUTION_TIME_IN_MS = 1;\nconst DD_ACTION_NAME_PROP = 'dd-action-name';\n\nexport class DdEventsInterceptor implements EventsInterceptor {\n    static ACTION_EVENT_DROPPED_WARN_MESSAGE =\n        'An action event was dropped because either the `onPress` method arguments' +\n        ' were undefined or they were missing the target information.';\n\n    private debouncingStartedTimestamp = Number.MIN_VALUE;\n\n    interceptOnPress(...args: any[]): void {\n        if (args.length > 0 && args[0] && args[0]._targetInst) {\n            const currentTime = Date.now();\n            const timestampDifference = Math.abs(\n                Date.now() - this.debouncingStartedTimestamp\n            );\n            if (timestampDifference > DEBOUNCE_EVENT_THRESHOLD_IN_MS) {\n                const targetNode = args[0]._targetInst;\n                this.handleTargetEvent(targetNode, args[0]);\n                // we add an approximated 1 millisecond for the execution time of the `handleTargetEvent` function\n                this.debouncingStartedTimestamp =\n                    currentTime + HANDLE_EVENT_APP_EXECUTION_TIME_IN_MS;\n            }\n        } else {\n            InternalLog.log(\n                DdEventsInterceptor.ACTION_EVENT_DROPPED_WARN_MESSAGE,\n                SdkVerbosity.WARN\n            );\n        }\n    }\n\n    private handleTargetEvent(targetNode: any, event: unknown) {\n        if (targetNode) {\n            const resolvedTargetName = this.resolveTargetName(targetNode);\n            DdRum.addAction(\n                RumActionType.TAP,\n                resolvedTargetName,\n                {},\n                undefined,\n                event as GestureResponderEvent\n            );\n        }\n    }\n\n    private resolveTargetName(targetNode: any): string {\n        const closestActionLabel = this.findClosestActionLabel(targetNode);\n        if (closestActionLabel != null) {\n            return closestActionLabel;\n        }\n        const accessibilityLabel = targetNode.memoizedProps?.accessibilityLabel;\n        if (accessibilityLabel != null) {\n            return accessibilityLabel;\n        }\n        const elementTypeName = this.resolveElementTypeName(\n            targetNode.elementType\n        );\n        return elementTypeName || UNKNOWN_TARGET_NAME;\n    }\n\n    private resolveElementTypeName(elementType: any): string | null {\n        let elementTypeName = null;\n        if (typeof elementType === 'string') {\n            elementTypeName = elementType;\n        } else if (elementType && typeof elementType.name === 'string') {\n            elementTypeName = elementType.name;\n        }\n        return elementTypeName;\n    }\n\n    private findClosestActionLabel(targetNode: any): string | null {\n        let currentNode = targetNode;\n        while (currentNode) {\n            const props = currentNode.memoizedProps;\n            if (props && props[DD_ACTION_NAME_PROP]) {\n                return props[DD_ACTION_NAME_PROP];\n            }\n            currentNode = currentNode.return;\n        }\n        return null;\n    }\n}\n"]}