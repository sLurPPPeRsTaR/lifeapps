{"version":3,"sources":["distributedTracing.tsx"],"names":["getPropagatorsForHost","DISCARDED_TRACE_ATTRIBUTES","samplingPriorityHeader","tracingStrategy","getTracingAttributes","hostname","firstPartyHostsRegexMap","tracingSamplingRate","propagatorsForHost","generateTracingAttributesWithSampling","propagatorTypes","isSampled","Math","random","tracingAttributes","traceId","TraceIdentifier","spanId","rulePsr","MAX_32_BITS_NUMBER","MAX_31_BITS_NUMBER","constructor","radix","low","high","str","mod","floor","toString","length","Array","join"],"mappings":"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","sourcesContent":["/*\n * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2016-Present Datadog, Inc.\n */\n\nimport type { PropagatorType } from '../../../types';\n\nimport type { Hostname } from './firstPartyHosts';\nimport { getPropagatorsForHost } from './firstPartyHosts';\nimport type { RegexMap } from './interfaces/RequestProxy';\n\nexport type DdRumResourceTracingAttributes =\n    | {\n          tracingStrategy: 'KEEP';\n          traceId: TraceId;\n          spanId: SpanId;\n          samplingPriorityHeader: '1' | '0';\n          rulePsr: number;\n          propagatorTypes: PropagatorType[];\n      }\n    | {\n          tracingStrategy: 'DISCARD';\n          traceId?: void;\n          spanId?: void;\n          samplingPriorityHeader: '0';\n      };\n\nconst DISCARDED_TRACE_ATTRIBUTES: DdRumResourceTracingAttributes = {\n    samplingPriorityHeader: '0',\n    tracingStrategy: 'DISCARD'\n};\n\nexport const getTracingAttributes = ({\n    hostname,\n    firstPartyHostsRegexMap,\n    tracingSamplingRate\n}: {\n    hostname: Hostname | null;\n    firstPartyHostsRegexMap: RegexMap;\n    tracingSamplingRate: number;\n}): DdRumResourceTracingAttributes => {\n    if (hostname === null) {\n        return DISCARDED_TRACE_ATTRIBUTES;\n    }\n    const propagatorsForHost = getPropagatorsForHost(\n        hostname,\n        firstPartyHostsRegexMap\n    );\n    if (propagatorsForHost) {\n        return generateTracingAttributesWithSampling(\n            tracingSamplingRate,\n            propagatorsForHost\n        );\n    }\n    return DISCARDED_TRACE_ATTRIBUTES;\n};\n\nconst generateTracingAttributesWithSampling = (\n    tracingSamplingRate: number,\n    propagatorTypes: PropagatorType[]\n): DdRumResourceTracingAttributes => {\n    const isSampled = Math.random() * 100 <= tracingSamplingRate;\n    const tracingAttributes: DdRumResourceTracingAttributes = {\n        traceId: new TraceIdentifier() as TraceId,\n        spanId: new TraceIdentifier() as SpanId,\n        samplingPriorityHeader: isSampled ? '1' : '0',\n        tracingStrategy: 'KEEP',\n        rulePsr: tracingSamplingRate / 100,\n        propagatorTypes\n    };\n\n    return tracingAttributes;\n};\n\n/**\n * Using branded types will ensure we don't accidentally use\n * traceId for spanId when generating headers.\n */\nexport type TraceId = TraceIdentifier & {\n    _brand: 'traceId';\n};\n\nexport type SpanId = TraceIdentifier & {\n    _brand: 'spanId';\n};\n\n/*\n * This code was inspired from browser-sdk at (https://github.com/DataDog/browser-sdk/blob/0e9722d5b06f6d49264bc82cd254a207d647d66c/packages/rum-core/src/domain/tracing/tracer.ts#L190)\n */\nconst MAX_32_BITS_NUMBER = 4294967295; // 2^32-1\nconst MAX_31_BITS_NUMBER = 2147483647; // 2^31-1\nexport class TraceIdentifier {\n    private low: number;\n    private high: number;\n\n    constructor() {\n        // We need to have a 63 bits number max\n        this.high = Math.floor(Math.random() * MAX_31_BITS_NUMBER);\n        this.low = Math.floor(Math.random() * MAX_32_BITS_NUMBER);\n    }\n\n    toString = (radix: number) => {\n        let low = this.low;\n        let high = this.high;\n        let str = '';\n\n        while (high > 0 || low > 0) {\n            const mod = (high % radix) * (MAX_32_BITS_NUMBER + 1) + low;\n            high = Math.floor(high / radix);\n            low = Math.floor(mod / radix);\n            str = (mod % radix).toString(radix) + str;\n        }\n        return str;\n    };\n\n    /**\n     * This function pads the trace with `0`.\n     * It should not be used with a `length` lower than the trace, as we return the full trace in this case.\n     * @param radix radix for the trace\n     * @param length minimum length\n     * @returns padded string\n     */\n    toPaddedString = (radix: number, length: number) => {\n        const traceId = this.toString(radix);\n        if (traceId.length > length) {\n            return traceId;\n        }\n        return Array(length - traceId.length + 1).join('0') + traceId;\n    };\n}\n"]}