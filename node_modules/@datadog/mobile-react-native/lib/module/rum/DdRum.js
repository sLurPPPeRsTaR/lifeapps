function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2016-Present Datadog, Inc.
 */
import { NativeModules } from 'react-native';
import { InternalLog } from '../InternalLog';
import { SdkVerbosity } from '../SdkVerbosity';
import { TimeProvider } from '../TimeProvider';
import { DdSdk } from '../foundation';
import { bufferVoidNativeCall } from '../sdk/DatadogProvider/Buffer/bufferNativeCall';
import { generateActionEventMapper } from './eventMappers/actionEventMapper';
import { generateErrorEventMapper } from './eventMappers/errorEventMapper';
import { generateResourceEventMapper } from './eventMappers/resourceEventMapper';
const timeProvider = new TimeProvider();

const generateEmptyPromise = () => new Promise(resolve => resolve());

class DdRumWrapper {
  constructor() {
    _defineProperty(this, "nativeRum", NativeModules.DdRum);

    _defineProperty(this, "lastActionData", void 0);

    _defineProperty(this, "errorEventMapper", generateErrorEventMapper(undefined));

    _defineProperty(this, "resourceEventMapper", generateResourceEventMapper(undefined));

    _defineProperty(this, "actionEventMapper", generateActionEventMapper(undefined));

    _defineProperty(this, "callNativeStopAction", (type, name, context, timestampMs) => {
      const mappedEvent = this.actionEventMapper.applyEventMapper({
        type,
        name,
        context,
        timestampMs
      });

      if (!mappedEvent) {
        return bufferVoidNativeCall(() => this.nativeRum.stopAction(type, name, {
          '_dd.action.drop_action': true
        }, timestampMs));
      }

      return bufferVoidNativeCall(() => this.nativeRum.stopAction(mappedEvent.type, mappedEvent.name, mappedEvent.context, mappedEvent.timestampMs));
    });

    _defineProperty(this, "getStopActionNativeCallArgs", args => {
      if (isNewStopActionAPI(args)) {
        return [args[0], args[1], args[2] || {}, args[3] || timeProvider.now()];
      }

      if (isOldStopActionAPI(args)) {
        if (this.lastActionData) {
          DdSdk.telemetryDebug('DDdRum.stopAction called with the old signature');
          const {
            type,
            name
          } = this.lastActionData;
          return [type, name, args[0] || {}, args[1] || timeProvider.now()];
        }

        InternalLog.log('DdRum.startAction needs to be called before DdRum.stopAction', SdkVerbosity.WARN);
      } else {
        InternalLog.log('DdRum.stopAction was called with wrong arguments', SdkVerbosity.WARN);
      }

      return null;
    });
  }

  startView(key, name, context = {}, timestampMs = timeProvider.now()) {
    InternalLog.log(`Starting RUM View “${name}” #${key}`, SdkVerbosity.DEBUG);
    return bufferVoidNativeCall(() => this.nativeRum.startView(key, name, context, timestampMs));
  }

  stopView(key, context = {}, timestampMs = timeProvider.now()) {
    InternalLog.log(`Stopping RUM View #${key}`, SdkVerbosity.DEBUG);
    return bufferVoidNativeCall(() => this.nativeRum.stopView(key, context, timestampMs));
  }

  startAction(type, name, context = {}, timestampMs = timeProvider.now()) {
    InternalLog.log(`Starting RUM Action “${name}” (${type})`, SdkVerbosity.DEBUG);
    this.lastActionData = {
      type,
      name
    };
    return bufferVoidNativeCall(() => this.nativeRum.startAction(type, name, context, timestampMs));
  }

  stopAction(...args) {
    InternalLog.log('Stopping current RUM Action', SdkVerbosity.DEBUG);
    const nativeCallArgs = this.getStopActionNativeCallArgs(args);
    this.lastActionData = undefined;

    if (!nativeCallArgs) {
      return generateEmptyPromise();
    }

    return this.callNativeStopAction(...nativeCallArgs);
  }

  addAction(type, name, context = {}, timestampMs = timeProvider.now(), actionContext) {
    const mappedEvent = this.actionEventMapper.applyEventMapper({
      type,
      name,
      context,
      timestampMs,
      actionContext
    });

    if (!mappedEvent) {
      return generateEmptyPromise();
    }

    InternalLog.log(`Adding RUM Action “${name}” (${type})`, SdkVerbosity.DEBUG);
    return bufferVoidNativeCall(() => this.nativeRum.addAction(mappedEvent.type, mappedEvent.name, mappedEvent.context, mappedEvent.timestampMs));
  }

  startResource(key, method, url, context = {}, timestampMs = timeProvider.now()) {
    InternalLog.log(`Starting RUM Resource #${key} ${method}: ${url}`, SdkVerbosity.DEBUG);
    return bufferVoidNativeCall(() => this.nativeRum.startResource(key, method, url, context, timestampMs));
  }

  stopResource(key, statusCode, kind, size = -1, context = {}, timestampMs = timeProvider.now(), resourceContext) {
    const mappedEvent = this.resourceEventMapper.applyEventMapper({
      key,
      statusCode,
      kind,
      size,
      context,
      timestampMs,
      resourceContext
    });

    if (!mappedEvent) {
      /**
       * To drop the resource we call `stopResource` and pass the `_dd.drop_resource` attribute in the context.
       * It will be picked up by the resource mappers we implement on the native side that will drop the resource.
       * This ensures we don't have any "started" resource left in memory on the native side.
       */
      return bufferVoidNativeCall(() => this.nativeRum.stopResource(key, statusCode, kind, size, {
        '_dd.resource.drop_resource': true
      }, timestampMs));
    }

    InternalLog.log(`Stopping RUM Resource #${key} status:${statusCode}`, SdkVerbosity.DEBUG);
    return bufferVoidNativeCall(() => this.nativeRum.stopResource(mappedEvent.key, mappedEvent.statusCode, mappedEvent.kind, mappedEvent.size, mappedEvent.context, mappedEvent.timestampMs));
  }

  addError(message, source, stacktrace, context = {}, timestampMs = timeProvider.now()) {
    const mappedEvent = this.errorEventMapper.applyEventMapper({
      message,
      source,
      stacktrace,
      context,
      timestampMs
    });

    if (!mappedEvent) {
      return generateEmptyPromise();
    }

    InternalLog.log(`Adding RUM Error “${message}”`, SdkVerbosity.DEBUG);
    const updatedContext = mappedEvent.context;
    updatedContext['_dd.error.source_type'] = 'react-native';
    return bufferVoidNativeCall(() => this.nativeRum.addError(mappedEvent.message, mappedEvent.source, mappedEvent.stacktrace, updatedContext, mappedEvent.timestampMs));
  }

  addTiming(name) {
    InternalLog.log(`Adding timing “${name}” to RUM View`, SdkVerbosity.DEBUG);
    return bufferVoidNativeCall(() => this.nativeRum.addTiming(name));
  }

  registerErrorEventMapper(errorEventMapper) {
    this.errorEventMapper = generateErrorEventMapper(errorEventMapper);
  }

  unregisterErrorEventMapper() {
    this.errorEventMapper = generateErrorEventMapper(undefined);
  }

  registerResourceEventMapper(resourceEventMapper) {
    this.resourceEventMapper = generateResourceEventMapper(resourceEventMapper);
  }

  unregisterResourceEventMapper() {
    this.resourceEventMapper = generateResourceEventMapper(undefined);
  }

  registerActionEventMapper(actionEventMapper) {
    this.actionEventMapper = generateActionEventMapper(actionEventMapper);
  }

  unregisterActionEventMapper() {
    this.actionEventMapper = generateActionEventMapper(undefined);
  }

}

const isNewStopActionAPI = args => {
  return typeof args[0] === 'string';
};

const isOldStopActionAPI = args => {
  return typeof args[0] === 'object' || typeof args[0] === 'undefined';
};

export const DdRum = new DdRumWrapper();
//# sourceMappingURL=DdRum.js.map