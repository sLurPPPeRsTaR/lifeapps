"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BoundedBuffer = void 0;

var _InternalLog = require("../../../InternalLog");

var _SdkVerbosity = require("../../../SdkVerbosity");

var _errorUtils = require("../../../errorUtils");

var _foundation = require("../../../foundation");

var _DatadogBuffer = require("./DatadogBuffer");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const DEFAULT_BUFFER_SIZE = 100;

class BoundedBuffer extends _DatadogBuffer.DatadogBuffer {
  constructor(bufferSize = DEFAULT_BUFFER_SIZE) {
    super();

    _defineProperty(this, "bufferSize", void 0);

    _defineProperty(this, "buffer", []);

    _defineProperty(this, "idTable", {});

    _defineProperty(this, "telemetryBuffer", {});

    _defineProperty(this, "addCallback", callback => {
      if (this.buffer.length < this.bufferSize) {
        this.buffer.push({
          callback,
          _type: 'VOID'
        });
      } else {
        this.addTelemetryEvent('Buffer overflow', '', 'BufferOverflow');
      }

      return new Promise(resolve => resolve(undefined));
    });

    _defineProperty(this, "addCallbackReturningId", callback => {
      try {
        const bufferId = this.generateRandomBufferId();

        if (this.buffer.length < this.bufferSize) {
          this.buffer.push({
            callback,
            returnedBufferId: bufferId,
            _type: 'RETURNING_ID'
          });
          this.idTable[bufferId] = null;
        } else {
          this.addTelemetryEvent('Buffer overflow', '', 'BufferOverflow');
        }

        return new Promise(resolve => resolve(bufferId));
      } catch (error) {
        this.addTelemetryEvent('Could not generate enough random numbers', (0, _errorUtils.getErrorStackTrace)(error), 'RandomIdGenerationError'); // Not using InternalLog here as it is not yet instantiated

        console.warn(`[Datadog] Could not generate enough random numbers for RUM buffer. Please check that Math.random is not overwritten. Math.random returns: ${Math.random()}`);
        return new Promise(resolve => resolve(''));
      }
    });

    _defineProperty(this, "addCallbackWithId", (callback, bufferId) => {
      if (this.idTable[bufferId] !== undefined) {
        this.buffer.push({
          callback,
          withBufferId: bufferId,
          _type: 'WITH_ID'
        });
      } else {
        this.addTelemetryEvent('Buffer overflow', '', 'BufferOverflow');
      }

      return new Promise(resolve => resolve(undefined));
    });

    _defineProperty(this, "drain", async () => {
      for (let bufferIndex = 0; bufferIndex < this.buffer.length; bufferIndex++) {
        try {
          const item = this.buffer[bufferIndex];

          if (item._type === 'RETURNING_ID') {
            try {
              // Here we want to await the callback result to make sure that it has registered the id returned
              // by the callback before executing the callback needing this id.
              // eslint-disable-next-line no-await-in-loop
              const callbackId = await item.callback();
              this.idTable[item.returnedBufferId] = callbackId;
            } catch (error) {
              _InternalLog.InternalLog.log(`Error running a callback returning an id in Buffer: ${error}`, _SdkVerbosity.SdkVerbosity.WARN);
            }

            continue;
          }

          if (item._type === 'WITH_ID') {
            const callbackId = this.idTable[item.withBufferId]; // callbackId can be `null` if the callback supposed to return the id errored. In this case, let's ignore the next callback.

            if (callbackId !== null && callbackId !== undefined) {
              item.callback(callbackId);
              delete this.idTable[item.withBufferId];
            } else {
              _InternalLog.InternalLog.log(`1 event was not sent as callback id was ${callbackId === null ? 'not set' : 'already unset'}`, _SdkVerbosity.SdkVerbosity.WARN);
            }

            continue;
          }

          item.callback();
        } catch (error) {
          _InternalLog.InternalLog.log(`Error while draining Datadog Buffer: ${error}`, _SdkVerbosity.SdkVerbosity.WARN);
        }
      }

      this.buffer = [];
      this.drainTelemetry();
    });

    _defineProperty(this, "generateRandomBufferId", () => {
      let tries = 0;

      while (tries < 20) {
        const hash = Math.random().toString(36).slice(2);

        if (this.idTable[hash] !== undefined) {
          tries++;
        } else {
          return hash;
        }
      }

      throw new Error('Could not generate random Buffer id');
    });

    _defineProperty(this, "addTelemetryEvent", (message, stack, kind) => {
      if (this.telemetryBuffer[kind]) {
        this.telemetryBuffer[kind].occurences++;
      } else {
        this.telemetryBuffer[kind] = {
          message,
          stack,
          kind,
          occurences: 1
        };
      }
    });

    _defineProperty(this, "drainTelemetry", () => {
      Object.values(this.telemetryBuffer).forEach(({
        message,
        stack,
        kind,
        occurences
      }) => {
        _foundation.DdSdk.telemetryError(`${message} happened ${occurences} times.`, stack, kind);
      });
    });

    this.bufferSize = bufferSize;
  }

}

exports.BoundedBuffer = BoundedBuffer;
//# sourceMappingURL=BoundedBuffer.js.map