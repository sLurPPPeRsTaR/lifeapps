"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DdLogs = void 0;

var _reactNative = require("react-native");

var _InternalLog = require("../InternalLog");

var _SdkVerbosity = require("../SdkVerbosity");

var _eventMapper = require("./eventMapper");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const generateEmptyPromise = () => new Promise(resolve => resolve());

class DdLogsWrapper {
  constructor() {
    _defineProperty(this, "nativeLogs", _reactNative.NativeModules.DdLogs);

    _defineProperty(this, "logEventMapper", (0, _eventMapper.generateEventMapper)(undefined));

    _defineProperty(this, "log", (message, context, status) => {
      _InternalLog.InternalLog.log(`Tracking ${status} log “${message}”`, _SdkVerbosity.SdkVerbosity.DEBUG);

      const event = this.logEventMapper.applyEventMapper({
        message,
        context,
        status
      });

      if (!event) {
        return generateEmptyPromise();
      }

      return this.nativeLogs[status](event.message, event.context);
    });
  }

  debug(message, context = {}) {
    return this.log(message, context, 'debug');
  }

  info(message, context = {}) {
    return this.log(message, context, 'info');
  }

  warn(message, context = {}) {
    return this.log(message, context, 'warn');
  }

  error(message, context = {}) {
    return this.log(message, context, 'error');
  }

  registerLogEventMapper(logEventMapper) {
    this.logEventMapper = (0, _eventMapper.generateEventMapper)(logEventMapper);
  }

  unregisterLogEventMapper() {
    this.logEventMapper = (0, _eventMapper.generateEventMapper)(undefined);
  }

}

const DdLogs = new DdLogsWrapper();
exports.DdLogs = DdLogs;
//# sourceMappingURL=DdLogs.js.map