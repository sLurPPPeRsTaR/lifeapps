"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TimeProvider = require("./TimeProvider");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const START_LABEL = '__start';
const STOP_LABEL = '__stop';
/**
 * Simple timer which records time ticks. Shouldn't be re-used once stopped.
 * All timestamps/durations returned are in milliseconds.
 */

class Timer {
  constructor(timeProvider = new _TimeProvider.TimeProvider()) {
    _defineProperty(this, "timeProvider", void 0);

    _defineProperty(this, "times", {});

    this.timeProvider = timeProvider;
  }

  get startTime() {
    return this.times[START_LABEL].unix;
  }

  get stopTime() {
    return this.startTime + this.durationBetween(START_LABEL, STOP_LABEL);
  }

  start() {
    this.recordTick(START_LABEL);
  }

  stop() {
    this.recordTick(STOP_LABEL);
  }

  recordTick(label) {
    this.times[label] = this.timeProvider.getTimestamp();
  }

  hasTickFor(label) {
    return label in this.times;
  }

  durationBetween(startLabel, endLabel) {
    this.checkLabelExists(startLabel);
    this.checkLabelExists(endLabel);
    const startTick = this.times[startLabel];
    const endTick = this.times[endLabel];
    return this.durationBetweenTicks(startTick, endTick);
  }

  timeAt(label) {
    this.checkLabelExists(label);
    return this.startTime + this.durationBetween(START_LABEL, label);
  }

  reset() {
    this.times = {};
  }

  durationBetweenTicks(start, end) {
    if (start.react_native != null && end.react_native != null) {
      return end.react_native - start.react_native;
    }

    return end.unix - start.unix;
  }

  checkLabelExists(label) {
    if (!this.hasTickFor(label)) {
      throw new Error(`Label ${label} is not registered`);
    }
  }

}

exports.default = Timer;
//# sourceMappingURL=Timer.js.map