"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DdRum = void 0;

var _reactNative = require("react-native");

var _InternalLog = require("../InternalLog");

var _SdkVerbosity = require("../SdkVerbosity");

var _TimeProvider = require("../TimeProvider");

var _foundation = require("../foundation");

var _bufferNativeCall = require("../sdk/DatadogProvider/Buffer/bufferNativeCall");

var _actionEventMapper = require("./eventMappers/actionEventMapper");

var _errorEventMapper = require("./eventMappers/errorEventMapper");

var _resourceEventMapper = require("./eventMappers/resourceEventMapper");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const timeProvider = new _TimeProvider.TimeProvider();

const generateEmptyPromise = () => new Promise(resolve => resolve());

class DdRumWrapper {
  constructor() {
    _defineProperty(this, "nativeRum", _reactNative.NativeModules.DdRum);

    _defineProperty(this, "lastActionData", void 0);

    _defineProperty(this, "errorEventMapper", (0, _errorEventMapper.generateErrorEventMapper)(undefined));

    _defineProperty(this, "resourceEventMapper", (0, _resourceEventMapper.generateResourceEventMapper)(undefined));

    _defineProperty(this, "actionEventMapper", (0, _actionEventMapper.generateActionEventMapper)(undefined));

    _defineProperty(this, "callNativeStopAction", (type, name, context, timestampMs) => {
      const mappedEvent = this.actionEventMapper.applyEventMapper({
        type,
        name,
        context,
        timestampMs
      });

      if (!mappedEvent) {
        return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.stopAction(type, name, {
          '_dd.action.drop_action': true
        }, timestampMs));
      }

      return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.stopAction(mappedEvent.type, mappedEvent.name, mappedEvent.context, mappedEvent.timestampMs));
    });

    _defineProperty(this, "getStopActionNativeCallArgs", args => {
      if (isNewStopActionAPI(args)) {
        return [args[0], args[1], args[2] || {}, args[3] || timeProvider.now()];
      }

      if (isOldStopActionAPI(args)) {
        if (this.lastActionData) {
          _foundation.DdSdk.telemetryDebug('DDdRum.stopAction called with the old signature');

          const {
            type,
            name
          } = this.lastActionData;
          return [type, name, args[0] || {}, args[1] || timeProvider.now()];
        }

        _InternalLog.InternalLog.log('DdRum.startAction needs to be called before DdRum.stopAction', _SdkVerbosity.SdkVerbosity.WARN);
      } else {
        _InternalLog.InternalLog.log('DdRum.stopAction was called with wrong arguments', _SdkVerbosity.SdkVerbosity.WARN);
      }

      return null;
    });
  }

  startView(key, name, context = {}, timestampMs = timeProvider.now()) {
    _InternalLog.InternalLog.log(`Starting RUM View “${name}” #${key}`, _SdkVerbosity.SdkVerbosity.DEBUG);

    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.startView(key, name, context, timestampMs));
  }

  stopView(key, context = {}, timestampMs = timeProvider.now()) {
    _InternalLog.InternalLog.log(`Stopping RUM View #${key}`, _SdkVerbosity.SdkVerbosity.DEBUG);

    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.stopView(key, context, timestampMs));
  }

  startAction(type, name, context = {}, timestampMs = timeProvider.now()) {
    _InternalLog.InternalLog.log(`Starting RUM Action “${name}” (${type})`, _SdkVerbosity.SdkVerbosity.DEBUG);

    this.lastActionData = {
      type,
      name
    };
    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.startAction(type, name, context, timestampMs));
  }

  stopAction(...args) {
    _InternalLog.InternalLog.log('Stopping current RUM Action', _SdkVerbosity.SdkVerbosity.DEBUG);

    const nativeCallArgs = this.getStopActionNativeCallArgs(args);
    this.lastActionData = undefined;

    if (!nativeCallArgs) {
      return generateEmptyPromise();
    }

    return this.callNativeStopAction(...nativeCallArgs);
  }

  addAction(type, name, context = {}, timestampMs = timeProvider.now(), actionContext) {
    const mappedEvent = this.actionEventMapper.applyEventMapper({
      type,
      name,
      context,
      timestampMs,
      actionContext
    });

    if (!mappedEvent) {
      return generateEmptyPromise();
    }

    _InternalLog.InternalLog.log(`Adding RUM Action “${name}” (${type})`, _SdkVerbosity.SdkVerbosity.DEBUG);

    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.addAction(mappedEvent.type, mappedEvent.name, mappedEvent.context, mappedEvent.timestampMs));
  }

  startResource(key, method, url, context = {}, timestampMs = timeProvider.now()) {
    _InternalLog.InternalLog.log(`Starting RUM Resource #${key} ${method}: ${url}`, _SdkVerbosity.SdkVerbosity.DEBUG);

    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.startResource(key, method, url, context, timestampMs));
  }

  stopResource(key, statusCode, kind, size = -1, context = {}, timestampMs = timeProvider.now(), resourceContext) {
    const mappedEvent = this.resourceEventMapper.applyEventMapper({
      key,
      statusCode,
      kind,
      size,
      context,
      timestampMs,
      resourceContext
    });

    if (!mappedEvent) {
      /**
       * To drop the resource we call `stopResource` and pass the `_dd.drop_resource` attribute in the context.
       * It will be picked up by the resource mappers we implement on the native side that will drop the resource.
       * This ensures we don't have any "started" resource left in memory on the native side.
       */
      return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.stopResource(key, statusCode, kind, size, {
        '_dd.resource.drop_resource': true
      }, timestampMs));
    }

    _InternalLog.InternalLog.log(`Stopping RUM Resource #${key} status:${statusCode}`, _SdkVerbosity.SdkVerbosity.DEBUG);

    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.stopResource(mappedEvent.key, mappedEvent.statusCode, mappedEvent.kind, mappedEvent.size, mappedEvent.context, mappedEvent.timestampMs));
  }

  addError(message, source, stacktrace, context = {}, timestampMs = timeProvider.now()) {
    const mappedEvent = this.errorEventMapper.applyEventMapper({
      message,
      source,
      stacktrace,
      context,
      timestampMs
    });

    if (!mappedEvent) {
      return generateEmptyPromise();
    }

    _InternalLog.InternalLog.log(`Adding RUM Error “${message}”`, _SdkVerbosity.SdkVerbosity.DEBUG);

    const updatedContext = mappedEvent.context;
    updatedContext['_dd.error.source_type'] = 'react-native';
    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.addError(mappedEvent.message, mappedEvent.source, mappedEvent.stacktrace, updatedContext, mappedEvent.timestampMs));
  }

  addTiming(name) {
    _InternalLog.InternalLog.log(`Adding timing “${name}” to RUM View`, _SdkVerbosity.SdkVerbosity.DEBUG);

    return (0, _bufferNativeCall.bufferVoidNativeCall)(() => this.nativeRum.addTiming(name));
  }

  registerErrorEventMapper(errorEventMapper) {
    this.errorEventMapper = (0, _errorEventMapper.generateErrorEventMapper)(errorEventMapper);
  }

  unregisterErrorEventMapper() {
    this.errorEventMapper = (0, _errorEventMapper.generateErrorEventMapper)(undefined);
  }

  registerResourceEventMapper(resourceEventMapper) {
    this.resourceEventMapper = (0, _resourceEventMapper.generateResourceEventMapper)(resourceEventMapper);
  }

  unregisterResourceEventMapper() {
    this.resourceEventMapper = (0, _resourceEventMapper.generateResourceEventMapper)(undefined);
  }

  registerActionEventMapper(actionEventMapper) {
    this.actionEventMapper = (0, _actionEventMapper.generateActionEventMapper)(actionEventMapper);
  }

  unregisterActionEventMapper() {
    this.actionEventMapper = (0, _actionEventMapper.generateActionEventMapper)(undefined);
  }

}

const isNewStopActionAPI = args => {
  return typeof args[0] === 'string';
};

const isOldStopActionAPI = args => {
  return typeof args[0] === 'object' || typeof args[0] === 'undefined';
};

const DdRum = new DdRumWrapper();
exports.DdRum = DdRum;
//# sourceMappingURL=DdRum.js.map