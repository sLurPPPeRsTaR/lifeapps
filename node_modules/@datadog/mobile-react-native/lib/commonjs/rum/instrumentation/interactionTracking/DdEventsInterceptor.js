"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DdEventsInterceptor = exports.UNKNOWN_TARGET_NAME = void 0;

var _InternalLog = require("../../../InternalLog");

var _SdkVerbosity = require("../../../SdkVerbosity");

var _DdRum = require("../../DdRum");

var _types = require("../../types");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const UNKNOWN_TARGET_NAME = 'unknown_target';
exports.UNKNOWN_TARGET_NAME = UNKNOWN_TARGET_NAME;
const DEBOUNCE_EVENT_THRESHOLD_IN_MS = 10;
const HANDLE_EVENT_APP_EXECUTION_TIME_IN_MS = 1;
const DD_ACTION_NAME_PROP = 'dd-action-name';

class DdEventsInterceptor {
  constructor() {
    _defineProperty(this, "debouncingStartedTimestamp", Number.MIN_VALUE);
  }

  interceptOnPress(...args) {
    if (args.length > 0 && args[0] && args[0]._targetInst) {
      const currentTime = Date.now();
      const timestampDifference = Math.abs(Date.now() - this.debouncingStartedTimestamp);

      if (timestampDifference > DEBOUNCE_EVENT_THRESHOLD_IN_MS) {
        const targetNode = args[0]._targetInst;
        this.handleTargetEvent(targetNode, args[0]); // we add an approximated 1 millisecond for the execution time of the `handleTargetEvent` function

        this.debouncingStartedTimestamp = currentTime + HANDLE_EVENT_APP_EXECUTION_TIME_IN_MS;
      }
    } else {
      _InternalLog.InternalLog.log(DdEventsInterceptor.ACTION_EVENT_DROPPED_WARN_MESSAGE, _SdkVerbosity.SdkVerbosity.WARN);
    }
  }

  handleTargetEvent(targetNode, event) {
    if (targetNode) {
      const resolvedTargetName = this.resolveTargetName(targetNode);

      _DdRum.DdRum.addAction(_types.RumActionType.TAP, resolvedTargetName, {}, undefined, event);
    }
  }

  resolveTargetName(targetNode) {
    var _targetNode$memoizedP;

    const closestActionLabel = this.findClosestActionLabel(targetNode);

    if (closestActionLabel != null) {
      return closestActionLabel;
    }

    const accessibilityLabel = (_targetNode$memoizedP = targetNode.memoizedProps) === null || _targetNode$memoizedP === void 0 ? void 0 : _targetNode$memoizedP.accessibilityLabel;

    if (accessibilityLabel != null) {
      return accessibilityLabel;
    }

    const elementTypeName = this.resolveElementTypeName(targetNode.elementType);
    return elementTypeName || UNKNOWN_TARGET_NAME;
  }

  resolveElementTypeName(elementType) {
    let elementTypeName = null;

    if (typeof elementType === 'string') {
      elementTypeName = elementType;
    } else if (elementType && typeof elementType.name === 'string') {
      elementTypeName = elementType.name;
    }

    return elementTypeName;
  }

  findClosestActionLabel(targetNode) {
    let currentNode = targetNode;

    while (currentNode) {
      const props = currentNode.memoizedProps;

      if (props && props[DD_ACTION_NAME_PROP]) {
        return props[DD_ACTION_NAME_PROP];
      }

      currentNode = currentNode.return;
    }

    return null;
  }

}

exports.DdEventsInterceptor = DdEventsInterceptor;

_defineProperty(DdEventsInterceptor, "ACTION_EVENT_DROPPED_WARN_MESSAGE", 'An action event was dropped because either the `onPress` method arguments' + ' were undefined or they were missing the target information.');
//# sourceMappingURL=DdEventsInterceptor.js.map