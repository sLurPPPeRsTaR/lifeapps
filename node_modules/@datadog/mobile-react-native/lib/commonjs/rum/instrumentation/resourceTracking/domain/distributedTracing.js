"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TraceIdentifier = exports.getTracingAttributes = void 0;

var _firstPartyHosts = require("./firstPartyHosts");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const DISCARDED_TRACE_ATTRIBUTES = {
  samplingPriorityHeader: '0',
  tracingStrategy: 'DISCARD'
};

const getTracingAttributes = ({
  hostname,
  firstPartyHostsRegexMap,
  tracingSamplingRate
}) => {
  if (hostname === null) {
    return DISCARDED_TRACE_ATTRIBUTES;
  }

  const propagatorsForHost = (0, _firstPartyHosts.getPropagatorsForHost)(hostname, firstPartyHostsRegexMap);

  if (propagatorsForHost) {
    return generateTracingAttributesWithSampling(tracingSamplingRate, propagatorsForHost);
  }

  return DISCARDED_TRACE_ATTRIBUTES;
};

exports.getTracingAttributes = getTracingAttributes;

const generateTracingAttributesWithSampling = (tracingSamplingRate, propagatorTypes) => {
  const isSampled = Math.random() * 100 <= tracingSamplingRate;
  const tracingAttributes = {
    traceId: new TraceIdentifier(),
    spanId: new TraceIdentifier(),
    samplingPriorityHeader: isSampled ? '1' : '0',
    tracingStrategy: 'KEEP',
    rulePsr: tracingSamplingRate / 100,
    propagatorTypes
  };
  return tracingAttributes;
};
/**
 * Using branded types will ensure we don't accidentally use
 * traceId for spanId when generating headers.
 */


/*
 * This code was inspired from browser-sdk at (https://github.com/DataDog/browser-sdk/blob/0e9722d5b06f6d49264bc82cd254a207d647d66c/packages/rum-core/src/domain/tracing/tracer.ts#L190)
 */
const MAX_32_BITS_NUMBER = 4294967295; // 2^32-1

const MAX_31_BITS_NUMBER = 2147483647; // 2^31-1

class TraceIdentifier {
  constructor() {
    _defineProperty(this, "low", void 0);

    _defineProperty(this, "high", void 0);

    _defineProperty(this, "toString", radix => {
      let low = this.low;
      let high = this.high;
      let str = '';

      while (high > 0 || low > 0) {
        const mod = high % radix * (MAX_32_BITS_NUMBER + 1) + low;
        high = Math.floor(high / radix);
        low = Math.floor(mod / radix);
        str = (mod % radix).toString(radix) + str;
      }

      return str;
    });

    _defineProperty(this, "toPaddedString", (radix, length) => {
      const traceId = this.toString(radix);

      if (traceId.length > length) {
        return traceId;
      }

      return Array(length - traceId.length + 1).join('0') + traceId;
    });

    // We need to have a 63 bits number max
    this.high = Math.floor(Math.random() * MAX_31_BITS_NUMBER);
    this.low = Math.floor(Math.random() * MAX_32_BITS_NUMBER);
  }

}

exports.TraceIdentifier = TraceIdentifier;
//# sourceMappingURL=distributedTracing.js.map