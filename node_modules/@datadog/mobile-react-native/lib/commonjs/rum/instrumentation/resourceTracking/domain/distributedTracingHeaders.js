"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTracingHeaders = exports.B3_MULTI_SAMPLED_HEADER_KEY = exports.B3_MULTI_SPAN_ID_HEADER_KEY = exports.B3_MULTI_TRACE_ID_HEADER_KEY = exports.B3_HEADER_KEY = exports.TRACECONTEXT_HEADER_KEY = exports.PARENT_ID_HEADER_KEY = exports.TRACE_ID_HEADER_KEY = exports.ORIGIN_RUM = exports.ORIGIN_HEADER_KEY = exports.SAMPLING_PRIORITY_HEADER_KEY = void 0;

var _types = require("../../../types");

/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2016-Present Datadog, Inc.
 */
const SAMPLING_PRIORITY_HEADER_KEY = 'x-datadog-sampling-priority';
/**
 * Datadog headers
 */

exports.SAMPLING_PRIORITY_HEADER_KEY = SAMPLING_PRIORITY_HEADER_KEY;
const ORIGIN_HEADER_KEY = 'x-datadog-origin';
exports.ORIGIN_HEADER_KEY = ORIGIN_HEADER_KEY;
const ORIGIN_RUM = 'rum';
exports.ORIGIN_RUM = ORIGIN_RUM;
const TRACE_ID_HEADER_KEY = 'x-datadog-trace-id';
exports.TRACE_ID_HEADER_KEY = TRACE_ID_HEADER_KEY;
const PARENT_ID_HEADER_KEY = 'x-datadog-parent-id';
/**
 * OTel headers
 */

exports.PARENT_ID_HEADER_KEY = PARENT_ID_HEADER_KEY;
const TRACECONTEXT_HEADER_KEY = 'traceparent';
exports.TRACECONTEXT_HEADER_KEY = TRACECONTEXT_HEADER_KEY;
const B3_HEADER_KEY = 'b3';
exports.B3_HEADER_KEY = B3_HEADER_KEY;
const B3_MULTI_TRACE_ID_HEADER_KEY = 'X-B3-TraceId';
exports.B3_MULTI_TRACE_ID_HEADER_KEY = B3_MULTI_TRACE_ID_HEADER_KEY;
const B3_MULTI_SPAN_ID_HEADER_KEY = 'X-B3-SpanId';
exports.B3_MULTI_SPAN_ID_HEADER_KEY = B3_MULTI_SPAN_ID_HEADER_KEY;
const B3_MULTI_SAMPLED_HEADER_KEY = 'X-B3-Sampled';
exports.B3_MULTI_SAMPLED_HEADER_KEY = B3_MULTI_SAMPLED_HEADER_KEY;

const getTracingHeaders = tracingAttributes => {
  const headers = [];

  if (tracingAttributes.tracingStrategy === 'DISCARD') {
    return headers;
  }

  tracingAttributes.propagatorTypes.forEach(propagator => {
    switch (propagator) {
      case _types.PropagatorType.DATADOG:
        {
          headers.push({
            header: ORIGIN_HEADER_KEY,
            value: ORIGIN_RUM
          }, {
            header: SAMPLING_PRIORITY_HEADER_KEY,
            value: tracingAttributes.samplingPriorityHeader
          }, {
            header: TRACE_ID_HEADER_KEY,
            value: tracingAttributes.traceId.toString(10)
          }, {
            header: PARENT_ID_HEADER_KEY,
            value: tracingAttributes.spanId.toString(10)
          });
          break;
        }

      case _types.PropagatorType.TRACECONTEXT:
        {
          headers.push({
            header: TRACECONTEXT_HEADER_KEY,
            value: generateTraceContextHeader({
              version: '00',
              traceId: tracingAttributes.traceId,
              parentId: tracingAttributes.spanId,
              isSampled: tracingAttributes.samplingPriorityHeader === '1'
            })
          });
          break;
        }

      case _types.PropagatorType.B3:
        {
          headers.push({
            header: B3_HEADER_KEY,
            value: generateB3Header({
              traceId: tracingAttributes.traceId,
              spanId: tracingAttributes.spanId,
              isSampled: tracingAttributes.samplingPriorityHeader === '1'
            })
          });
          break;
        }

      case _types.PropagatorType.B3MULTI:
        {
          headers.push({
            header: B3_MULTI_TRACE_ID_HEADER_KEY,
            value: tracingAttributes.traceId.toPaddedString(16, 32)
          }, {
            header: B3_MULTI_SPAN_ID_HEADER_KEY,
            value: tracingAttributes.spanId.toPaddedString(16, 16)
          }, {
            header: B3_MULTI_SAMPLED_HEADER_KEY,
            value: tracingAttributes.samplingPriorityHeader
          });
        }
    }
  });
  return headers;
};

exports.getTracingHeaders = getTracingHeaders;

const generateTraceContextHeader = ({
  version,
  traceId,
  parentId,
  isSampled
}) => {
  const flags = isSampled ? '01' : '00';
  return `${version}-${traceId.toPaddedString(16, 32)}-${parentId.toPaddedString(16, 16)}-${flags}`;
};

const generateB3Header = ({
  traceId,
  spanId,
  isSampled
}) => {
  const flags = isSampled ? '1' : '0';
  return `${traceId.toPaddedString(16, 32)}-${spanId.toPaddedString(16, 16)}-${flags}`;
};
//# sourceMappingURL=distributedTracingHeaders.js.map